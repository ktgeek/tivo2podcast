#!/usr/bin/env ruby

# This has -Z "iPhone" expanded so I could tweak a few things
# HandBrakeCLI -v 0 -e x264 -b 768 -2 -T -5 default --crop 5:0:0:0 -a 1 -E faac -B 48 -6 stereo -R 48 -D 0.0 -f mp4 -X 480 -x cabac=0:ref=2:me=umh:bframes=0:subme=6:8x8dct=0:trellis=0 -i input.mpg -o output.mpg

# You must have tivodecode for this to work.
# Your tivo mak will be read out of ~/.tivodecode_mak if it is available

# Adds the lib path next to the path the script is in to the head of
# the search patch
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib',
                                      'httpclient-2.1.2', 'lib'))
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'optparse'
require 'TiVo.rb'
require 'facets/progressbar.rb'
require 'sqlite3'
require 'rss'
#require 'pp'

HANDBRAKE = 'HandBrakeCLI'
ATOMICPARSLEY = 'AtomicParsley'
BASE_URL = 'http://temp.kgarner.com/tdstest/'

# Load the mak if we have a mak file
mak_file = ENV['HOME'] + '/.tivodecode_mak'
mak = nil
mak = File.read(mak_file).strip if File.exist?(mak_file)

def init_database(db)
  db.execute('create table status (
              id INTEGER PRIMARY KEY autoincrement,
              configname TEXT,
              rss_guid TEXT,
              s_name TEXT,
              s_ep_title TEXT,
              s_ep_number TEXT,
              s_ep_description TEXT,
              s_ep_length INTEGER,
              s_ep_timecap INTEGER,
              filename TEXT
              );')
end

# Open up the database we use for status
db = SQLite3::Database.new("tivodownload.db")
db.results_as_hash = true

# This should be made generic into a configuration
tivo_addr = '192.168.69.179'
tivo = TiVo::TiVo.new(tivo_addr, mak)

#shows = tivo.get_listings.videos.select { |s| s.title =~ /Batman/ }.sort_by { |s| s.time_captured }
shows = tivo.get_listings.videos.select { |s| s.title =~ /The Daily Show/ && !s.copy_protected? }.sort_by { |s| s.time_captured }

ps = db.prepare('insert into status(s_name, s_ep_title, s_ep_number, s_ep_description, s_ep_length, s_ep_timecap, filename) values (?, ?, ?, ?, ?, ?, ?, ?);')

# So starts the giant loop that processes the shows...
shows.each do |s|
  # Beef this up to capture the show title as well
  basename = s.title + '-' + s.time_captured.strftime("%Y%m%d")
  basename = basename + '-' + s.episode_title unless s.episode_title.nil?
  basename = basename + '-' + s.episode_number unless s.episode_number.nil?
  basename.sub!(/:/, '_')

  download = basename + ".mpg"
  transcode = basename + ".m4v"
  # I should add a check to see if the file exists or the transcoded
  # version of it, and if so, assume we already downloaded the file

  puts download
  
  if (!(File.exist?(download) || File.exist?(transcode)))
    tivo = TiVo::TiVo.new(tivo_addr, mak)

    # downlaod the file
    IO.popen("tivodecode -o \"#{download}\" -", 'wb') do |td|
      pbar = Console::ProgressBar.new(download, s.size)
      tivo.download_show(s) do |tc|
        td << tc
        pbar.inc(tc.length)
      end
      pbar.finish
      puts
    end

    command = %w/-v 0 -e x264 -b 768 -2 -T -5 default --crop 5:0:0:0 -a 1 -E faac -B 48 -6 stereo -R 48 -D 0.0 -f mp4 -X 480 -x cabac=0:ref=2:me=umh:bframes=0:subme=6:8x8dct=0:trellis=0 -i/ << download << '-o' << transcode
    returncode = system(HANDBRAKE, *command)

    if !returncode
      puts "something isn't working right, bailing"
      exit(1)
    end

    File.delete(download)

#   --title            ,  -s   (str)    Set the title tag: "moov.udta.meta.ilst.Â©nam.data"
#   --TVNetwork        ,  -n   (str)    Sets the TV Network name on the "tvnn" atom
#   --TVShowName       ,  -H   (str)    Sets the TV Show name on the "tvsh" atom
#   --TVEpisode        ,  -I   (str)    Sets the TV Episode on "tven":"209", but its a string: "209 Part 1"
#   --TVSeasonNum      ,  -U   (num)    Sets the TV Season number on the "tvsn" atom
#   --TVEpisodeNum     ,  -N   (num)    Sets the TV Episode number on the "tves" atom
#   --description      ,  -p   (str)    Sets the description on the "desc" atom

    episode_title = nil
    unless s.episode_title.nil?
      episode_title = s.episode_title
    else
      episode_title = s.time_captured.strftime("%m/%d/%Y")
    end
    
    showtitle = s.title + ': ' + s.episode_title
    showtitle = showtitle + ' (' + s.episode_number + ')' unless s.episode_number.nil?
    
    command = Array.new << transcode << '-W' << '--title' << showtitle <<
      '--TVShowName' << s.title << '--TVEpisode' << episode_title
    command << '--TVEpisodeNum' << s.episode_number unless s.episode_number.nil?
    command << '--TVNetwork' << s.station unless s.station.nil?
    command << '--description' << s.description unless s.description.nil?
    
    returncode = system(ATOMICPARSLEY, *command)
    if !returncode
      puts "something isn't working right, bailing"
      exit(1)
    end

    ps = db.prepare('insert into status(s_name, s_ep_title, s_ep_number, s_ep_description, s_ep_length, s_ep_timecap, filename) values (?, ?, ?, ?, ?, ?, ?, ?);')
    ps.execute(s.title, episode_title, s.episode_number, s.description, s.duraction, s.time_captured, transcode)

  else
    puts "Skipping #{basename} because it seems to exist"
  end
end

# Here is where I would generate RSS and also clean up older files
rss = RSS::Maker.make("2.0") do |maker|
  maker.channel.title = "The Daily Show"
  maker.channel.description = "My Daily Show RSS feed"
  maker.channel.link = "http://www.thedailyshow.com/"
  maker.channel.lastBuildDate = Time.now

  channel.itunes_author = channel.title
  channel.itunes_owner = RSS::ITunesChannelModel::ITunesOwner.new
  channel.itunes_owner.itunes_name='Keith Garner'
  channel.itunes_owner.itunes_email='kgarner@kgarner.com'
  
  maker.items.do_sort = true

  updateGUIDs = Array.new
  db.query("select * from status") do |row|
    maker.items.new_item do |item|
      item.title = row['s_ep_title']
      item.link = BASE_URL + row['filename']
      guid = row['rss_guid']
      if guid.nil?
        guid = RSS::Rss::Channel::Item::Guid.new
        updateGUIDs << [row['id'], guid]
      end
      item.guid.content = link
      item.guid.isPermaLink = true
      item.pubDate = row['s_ep_timecap']
      item.description = row['s_ep_description']
      item.itunes_summary = row['s_ep_description']
      item.itunes_explicit = "No"

      # I need to come back and do the time.  For now, I'm hard coding
      # to 32 minutes
      # time = row['s_ep_length'] item.itunes_duration =
      RSS::ITunesItemModel::ITunesDuraction.new(32, 00)

      item.enclosure =
        RSS::Rss::Channel::Item::Enclosure.new(item.link, row['filename'],
                                               'video/x-m4v')
    end
  end
end

File.open('rss.xml', 'w') { |f| f << rss.to_s }

db.close

# Local Variables:
# mode: ruby
# End:
