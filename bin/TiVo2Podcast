#!/usr/bin/env ruby
# Copyright 2010 Keith T. Garner. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# You must have tivodecode for this to work.
# Your tivo mak will be read out of ~/.tivodecode_mak if it is available
#
# Adds the lib path next to the path the script is in to the head of
# the search patch
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'rubygems'
require 'optparse'
require 'TiVo.rb'
require 'tivopodcast'
require 'facets/progressbar.rb'
require 'rss'
require 'rss/itunes'
require 'uri'
require 'ostruct'

CONFIG = OpenStruct.new({'tivo_addr' => '192.168.69.179',
                          'mak' => nil,
                          'verbose' => false,
                          'opt_config_names' => nil,
                          'tivodecode' => 'tivodecode',
                          'handbrake' => 'HandBrakeCLI',
                          'atomicparsley' => 'AtomicParsley'})

def download_show(show, name)
  tivo = TiVo::TiVo.new(CONFIG.tivo_addr, CONFIG.mak)

  # downlaod the file
  IO.popen("tivodecode -n -o \"#{name}\" -", 'wb') do |td|
    pbar = CONFIG.verbose ? Console::ProgressBar.new(name, show.size) : nil
    tivo.download_show(show) do |tc|
      td << tc
      pbar.inc(tc.length) unless pbar.nil?
    end
    pbar.finish unless pbar.nil?
    puts
  end
end

# Load the mak if we have a mak file
mak_file = ENV['HOME'] + '/.tivodecode_mak'
CONFIG.mak = File.read(mak_file).strip if File.exist?(mak_file)

opts = OptionParser.new
opts.on('-c CONFIG', '--config CONFIG',
        'Use the named config on this run (may be used multiple times)') do |c|
  CONFIG.opt_config_names = Array.new if CONFIG.opt_config_names.nil?
  CONFIG.opt_config_names << c
end
opts.on('-m MAK', '--mak MAK',
        'The TiVo\'s media access key') { |k| CONFIG.mak = k }
opts.on('-v', '--verbose') { CONFIG.verbose = true }
opts.on_tail('-h', '--help', 'Show this message') do
  puts opts
  exit
end
opts.parse(ARGV)

db = Tivo2Podcast::T2PDatabase.new((ENV['TIVO2PODCASTDIR'].nil? ?
                                    ENV['HOME'] :
                                    ENV['TIVO2PODCASTDIR']) +
                                   File::SEPARATOR + '.tivo2podcast.db')

configs = db.get_configs(CONFIG.opt_config_names)

tivo = TiVo::TiVo.new(CONFIG.tivo_addr, CONFIG.mak)
configs.each do |config|

  shows = tivo.get_shows_by_name(config['show_name'])

  # Only work on the X latest shows.  That way if there are 10 on the tivo,
  # but we only want to keep 4, we don't encode 6 of them just to throw them
  # out later in the cleanup phase.
  if shows.size > config['ep_to_keep']
    shows = shows.reverse[0, config['ep_to_keep']].reverse
  end

  # So starts the giant loop that processes the shows...
  shows.each do |s|
    # Beef this up to capture the show title as well
    basename = s.title + '-' + s.time_captured.strftime("%Y%m%d")
    basename = basename + '-' + s.episode_title unless s.episode_title.nil?
    basename = basename + '-' + s.episode_number unless s.episode_number.nil?
    basename.sub!(/:/, '_')

    download = basename + ".mpg"
    transcode = basename + ".m4v"

    # I should add a check to see if the file exists or the transcoded
    # version of it, and if so, assume we already downloaded the file
    if (!(File.exist?(download) || File.exist?(transcode)))
      download_show(s, download)
      
      transcoder = Tivo2Podcast::Transcoder.new(config, s)
      transcoder.transcode_show(download, transcode)

      File.delete(download)

      db.add_show(s, config, transcode)

     else
      puts "Skipping #{basename} because it seems to exist" if CONFIG.verbose
    end
  end

  # cleanup phase goes here
  deletes = db.show_cleanup(config)
  deletes.each { |f| File.delete(f) }

  rss = Tivo2Podcast::RssGenerator.new(config, db)
  File.open(config['rss_filename'], 'w') { |f| f << rss.generate() }
end

# Local Variables:
# mode: ruby
# End:
