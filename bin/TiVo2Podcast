#!/usr/bin/env ruby

# This has -Z "iPhone" expanded so I could tweak a few things
# HandBrakeCLI -v 0 -e x264 -b 768 -2 -T -5 default --crop 5:0:0:0 -a 1 -E faac -B 48 -6 stereo -R 48 -D 0.0 -f mp4 -X 480 -x cabac=0:ref=2:me=umh:bframes=0:subme=6:8x8dct=0:trellis=0 -i input.mpg -o output.mpg

# You must have tivodecode for this to work.
# Your tivo mak will be read out of ~/.tivodecode_mak if it is available

# Adds the lib path next to the path the script is in to the head of
# the search patch
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib',
                                      'httpclient-2.1.2', 'lib'))
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'optparse'
require 'TiVovi .rb'
require 'tivopodcast'
require 'facets/progressbar.rb'
require 'rss'
require 'rss/itunes'
require 'uri'

# This should be made generic into a configuration
TIVO_ADDR = '192.168.69.179'

def download_show(show, name)
  tivo = TiVo::TiVo.new(TIVO_ADDR, MAK)

  # downlaod the file
  IO.popen("tivodecode -o \"#{name}\" -", 'wb') do |td|
    pbar = Console::ProgressBar.new(name, show.size)
    tivo.download_show(show) do |tc|
      td << tc
      pbar.inc(tc.length)
    end
    pbar.finish
    puts
  end
end

# Load the mak if we have a mak file
mak_file = ENV['HOME'] + '/.tivodecode_mak'
MAK = File.read(mak_file).strip if File.exist?(mak_file)

opt_config_names = Array.new
opts = OptionParser.new
opts.on('-c CONFIG', '--config CONFIG',
        'Use the named config on this run') { |c| opt_config_names << c }
opts.on('-m MAK', '--mak MAK', 'The TiVo\'s media access key') { |k| mak = k }
opts.on_tail('-h', '--help', 'Show this message') do
  puts opts
  exit
end
opts.parse(ARGV)

db = Tivo2Podcast::T2PDatabase.new((ENV['TIVO2PODCASTDIR'].nil? ?
                                    ENV['HOME'] :
                                    ENV['TIVO2PODCASTDIR']) +
                                   File::SEPARATOR + '.tivo2podcast.db')

configs = db.get_configs(opt_config_names)

tivo = TiVo::TiVo.new(TIVO_ADDR, MAK)
configs.each do |config|

  shows = tivo.get_shows_by_name(config['show_name'])

  # So starts the giant loop that processes the shows...
  shows.each do |s|
    # Beef this up to capture the show title as well
    basename = s.title + '-' + s.time_captured.strftime("%Y%m%d")
    basename = basename + '-' + s.episode_title unless s.episode_title.nil?
    basename = basename + '-' + s.episode_number unless s.episode_number.nil?
    basename.sub!(/:/, '_')

    download = basename + ".mpg"
    transcode = basename + ".m4v"

    # I should add a check to see if the file exists or the transcoded
    # version of it, and if so, assume we already downloaded the file
    if (!(File.exist?(download) || File.exist?(transcode)))
      download_show(s, download)

      transcoder = Tivo2Podcast::Transcoder.new(s)
      transocder.transcode_show(download, transcode)

      File.delete(download)

      db.add_show(s, config, transcode)

    else
      puts "Skipping #{basename} because it seems to exist"
    end
  end

  # cleanup phase goes here

  rss = Tivo2Podcast::RssGenerator.new(config, db)
  File.open(config['rss_filename'], 'w') { |f| f << rss.generate() }
end

# Local Variables:
# mode: ruby
# End:
