#!/usr/bin/env ruby
# Copyright 2010 Keith T. Garner. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# You must have tivodecode for this to work.
# Your tivo mak will be read out of ~/.tivodecode_mak if it is available

# Adds the lib path next to the path the script is in to the head of
# the search patch
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib',
                                      'tivo'))

require 'rubygems'
require 'optparse'
require 'TiVo.rb'
require 'ansi/progressbar.rb'

def do_menu(tivo_items, menu_size=10)
  offset = 0
  display_items = nil
  filter_copyprotected = true
  queue = Array.new
  
  while (true)
    display_items = tivo_items.videos[offset, menu_size]
    puts
    display_items.each_with_index do |item, i|
      unless filter_copyprotected && item.copy_protected?
        printf("%2d) %3d | %-43.43s | %13.13s | %5s\n", i + offset,
               item.channel, item.printable_title,
               item.time_captured.strftime('%m/%d %I:%M%p'), item.human_duration)
      end
    end
    print "\nSelect vid, (n)ext/(p)rev #{menu_size}," +
      " # to change menu, (s)ort, (d)ownload, (q)uit: "
    selection = nil
    input = $stdin.readline.strip
    case input
    when 'p':
      t_offset = offset - menu_size
      offset = t_offset if t_offset >= 0
    when 'n':
      t_offset = offset + menu_size
      offset = t_offset if t_offset < tivo_items.videos.length
    when '#':
      print "Enter the number of lines to display: "
      numInput= $stdin.readline.strip.to_i
      if !numInput.nil? && numInput > 0
        menu_size=numInput
      end
    when 's':
      print "Select sort: t/T=title, d/D=date, c/C=chan, cap to reverse, other to abort:"
      sortInput= $stdin.readline.strip
      case sortInput
      when 't','T':
        tivo_items.videos=tivo_items.videos.sort_by { |ti| ti.printable_title }
        tivo_items.videos.reverse! if sortInput=='T'
        offset=0
      when 'c','C':
        tivo_items.videos=tivo_items.videos.sort_by { |a| a.channel }
        tivo_items.videos.reverse! if sortInput=='C'
        offset=0
      when 'd', 'D':
        tivo_items.videos=tivo_items.videos.sort_by { |ti| ti.time_captured }
        tivo_items.videos.reverse! if sortInput=='D'
        offset=0
      end
    when 'd':
        break
    when 'q':
        exit(0)
    else
      selection = input.to_i if input.eql?(input.to_i.to_s)
    end
    unless selection.nil? || selection >= tivo_items.videos.length ||
        selection < 0
      queue << tivo_items.videos[selection]
    end
  end
  return queue
end

def make_filename(tivo_item)
  name = tivo_item.title
  ep = tivo_item.episode_title
  name = name + "-" + ep unless ep.nil?
  unless ep.nil? || tivo_item.episode_number.nil?
    name = name + "-" + tivo_item.episode_number
  end
  name.sub!(/:/, '_')
  name.sub!(/\//, '_')
  name = name + ".mpg"
  return name
end

# Load the mak if we have a mak file
mak_file = ENV['HOME'] + '/.tivodecode_mak'
mak = nil
mak = File.read(mak_file).strip if File.exist?(mak_file)

# Parse the options to get the rest (or override the above)
tivo_addr = nil
opts = OptionParser.new
opts.on('-m MAK', '--mak MAK', 'The TiVo\'s media access key') { |k| mak = k }
opts.on('-t IP', '--tivo IP', 'The IP address of your TiVo') do |ip|
  tivo_addr = ip
end
opts.on_tail('-h', '--help', 'Show this message') do
  puts opts
  exit
end
opts.parse(ARGV)

if tivo_addr.nil? || mak.nil?
  puts "Must have TiVo IP address and MAK to function."
  exit(1)
end

tivo = TiVo::TiVo.new(tivo_addr, mak)

downloads = do_menu(tivo.get_listings)

downloads.each do |dl|
  tivo = TiVo::TiVo.new(tivo_addr, mak)
  dl_name = make_filename(dl)

  puts "Attemping to download " + dl.printable_title()
  IO.popen("tivodecode -n -o \"#{dl_name}\" -", 'wb') do |td|
    pbar = ANSI::ProgressBar.new(dl_name, dl.size)
    tivo.download_show(dl) do |tc|
      td << tc
      pbar.inc(tc.length)
    end
    pbar.finish
    puts
  end
  sleep 60
end

# Local Variables:
# mode: ruby
# End:
